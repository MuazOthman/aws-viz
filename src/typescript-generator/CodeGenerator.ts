import { Application, Component } from '../diagram/model';
import { writeFileSync, existsSync, readFileSync, mkdirSync } from 'fs';
import uniq from 'lodash.uniq';
import { AbstractCodeGenerator } from '../AbstractCodeGenerator';
import { join } from 'path';

const StaticFiles = {
  'tsconfig.json': JSON.stringify(
    {
      compilerOptions: {
        moduleResolution: 'node',
        target: 'ES2019',
        module: 'commonjs',
        declaration: false,
        experimentalDecorators: true,
        emitDecoratorMetadata: true,
        esModuleInterop: true,
        preserveConstEnums: true,
        allowSyntheticDefaultImports: true,
        noImplicitAny: false,
        strictNullChecks: false,
        noImplicitThis: true,
        noUnusedLocals: false,
        noUnusedParameters: false,
        noImplicitReturns: true,
        noFallthroughCasesInSwitch: false,
        strictPropertyInitialization: false,
        sourceMap: true,
        lib: ['ES2020'],
        resolveJsonModule: true,
      },
      exclude: ['node_modules'],
    },
    null,
    2,
  ),
  '.prettierrc': JSON.stringify(
    {
      semi: true,
      trailingComma: 'all',
      singleQuote: true,
      printWidth: 120,
      tabWidth: 2,
      bracketSpacing: true,
    },
    null,
    2,
  ),
  '.gitignore': `[Ll]og/
[Ll]ogs/

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

### Node ###
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
**/node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache


# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

### VisualStudioCode ###
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

### VisualStudioCode Patch ###
# Ignore all local history of files
.history

# End of https://www.toptal.com/developers/gitignore/api/node,visualstudiocode
.aws-sam
dist
/build
`,
  '.eslintrc.js': `module.exports = {
  extends: [
    "plugin:@typescript-eslint/recommended",
    "plugin:prettier/recommended",
  ],
  parser: "@typescript-eslint/parser",
  parserOptions: {
    ecmaVersion: 2019,
    project: "./tsconfig.json",
    sourceType: "module",
  },
  rules: {
    "prettier/prettier": [
      "error",
      {
        endOfLine: "auto",
      },
    ],
    "@typescript-eslint/no-empty-interface": ["error"],
    "@typescript-eslint/no-unused-expressions": ["error"],
    "@typescript-eslint/no-use-before-define": ["error"],
    "@typescript-eslint/no-useless-constructor": ["error"],
    "@typescript-eslint/return-await": ["error"],
    "@typescript-eslint/await-thenable": ["error"],
    "@typescript-eslint/prefer-as-const": ["warn"],
    "@typescript-eslint/prefer-namespace-keyword": ["warn"],
    "@typescript-eslint/prefer-readonly": ["warn"],
    "@typescript-eslint/promise-function-async": ["error"],
    "@typescript-eslint/naming-convention": [
      "warn",
      {
        selector: "variable",
        types: ["boolean"],
        format: ["PascalCase"],
        prefix: ["is", "should", "has", "can", "did", "will"],
      },
      {
        selector: "interface",
        format: ["PascalCase"],
        custom: {
          regex: "^I[A-Z]",
          match: true,
        },
      },
      {
        selector: "memberLike",
        modifiers: ["private"],
        format: ["camelCase"],
        leadingUnderscore: "require",
      },
    ],
  },
};
  `,
  '.eslintignore': `build
node_modules
tsconfig.json
.eslintrc.js`,
  'webpack.config.ts': `// Adapted from Matt Morgan at https://github.com/elthrasher/sam-typescript-webpack-sample/blob/master/webpack.config.ts
// Original article: https://dev.to/elthrasher/managing-multiple-functions-with-aws-sam-and-webpack-1581
import { EventSource } from 'aws-sdk/clients/configservice';
import { readFileSync } from 'fs';
import { join, resolve } from 'path';
import { Configuration } from 'webpack';
import { yamlParse } from 'yaml-cfn';

interface ISamFunction {
  Type: string;
  Properties: {
    AssumeRolePolicyDocument?: JSON;
    AutoPublishAlias?: string;
    AutoPublishCodeSha256?: string;
    CodeUri?: string;
    Description?: string;
    Environment?: {
      Variables: {
        [key: string]: string;
      };
    };
    Events?: EventSource;
    FunctionName?: string;
    Handler: string;
    Layers?: { [Ref: string]: string }[];
    Runtime: string;
    Timeout?: number;
    Tracing?: string;
    VersionDescription?: string;
  };
}

// Grab Globals and Resources as objects from template yaml
const { Globals, Resources } = yamlParse(readFileSync(join(__dirname, 'template.yaml'), 'utf-8'));

// We use globals as a fallback, so make sure that object exists.
const GlobalFunction = Globals?.Function || {};

// Where my function source lives
const HandlerPath = './src/handlers';

const Entries = Object.values(Resources)
  // Take only the Lambda function resources
  .filter((resource: ISamFunction) => resource.Type === 'AWS::Serverless::Function')
  // Only nodejs Lambda functions
  .filter((resource: ISamFunction) => (resource.Properties.Runtime || GlobalFunction.Runtime).startsWith('nodejs'))
  // Get filename for each function and output directory (if desired)
  .map((resource: ISamFunction) => ({
    filename: resource.Properties.Handler.split('.')[0],
    entryPath: resource.Properties.CodeUri.split('/').splice(1).join('/'),
  }))
  // Create hashmap of filename to file path
  .reduce(
    (resources, resource) =>
      Object.assign(resources, {
        [\`$\{resource.entryPath}/$\{resource.filename}\`]: \`$\{HandlerPath}/$\{resource.entryPath}/$\{resource.filename}.ts\`,
      }),
    {},
  );

const Config: Configuration = {
  entry: Entries,
  output: {
    filename: '[name].js',
    libraryTarget: 'commonjs2',
    path: resolve(__dirname, 'build'),
  },
  mode: process.env.NODE_ENV === 'dev' ? 'development' : 'production',
  externals:
    process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'dev' ? [] : ['aws-sdk', '@types/aws-lambda'],
  module: {
    rules: [{ test: /\.ts$/, loader: 'ts-loader' }],
  },
  resolve: {
    extensions: ['.js', '.ts'],
  },
  target: 'node',
  cache: true,
};

export default Config;
`,
};

export class CodeGenerator extends AbstractCodeGenerator {
  private _fixStaticFile(fileName: string, shouldWriteChanges: boolean): boolean {
    const filePath = join(this.workspaceRoot, fileName);
    const hasFile = existsSync(filePath);
    const shouldBeFixed = !hasFile;
    if (shouldBeFixed && shouldWriteChanges) {
      writeFileSync(filePath, StaticFiles[fileName]);
    }
    return shouldBeFixed;
  }

  private _fixPackageFile(shouldWriteChanges: boolean): boolean {
    const filePath = join(this.workspaceRoot, 'package.json');
    const hasFile = existsSync(filePath);
    const pkg = hasFile
      ? JSON.parse(readFileSync(filePath).toString('utf-8'))
      : {
          name: 'package-name-here',
          version: '1.0.0',
          description: 'Package description goes here',
          main: 'index.ts',
          scripts: {
            test: 'jest --passWithNoTests',
            lint: 'tsc --noemit && eslint --ext .ts .',
            build: 'npm run clean && webpack --progress',
            clean: 'rimraf build',
          },
          devDependencies: {},
          dependencies: {},
          author: '',
          license: 'ISC',
        };
    if (!pkg.devDependencies) pkg.devDependencies = {};
    if (!pkg.dependencies) pkg.dependencies = {};
    let shouldBeFixed = !hasFile;
    const devDependencies = {
      '@types/aws-lambda': '^8.10.86',
      '@types/jest': '^29.2.3',
      '@types/node': '^18.11.10',
      '@types/webpack': '^5.28.0',
      '@typescript-eslint/eslint-plugin': '^5.11.0',
      '@typescript-eslint/parser': '^5.11.0',
      eslint: '^8.9.0',
      'eslint-config-prettier': '^8.3.0',
      'eslint-plugin-prettier': '^4.0.0',
      jest: '^29.3.1',
      npm: '^9.1.3',
      prettier: '^2.1.1',
      rimraf: '^3.0.2',
      'ts-jest': '^29.0.3',
      'ts-loader': '^9.2.6',
      'ts-node': '^10.5.0',
      typescript: '^4.0.2',
      webpack: '^5.68.0',
      'webpack-cli': '^5.0.0',
      'yaml-cfn': '^0.3.1',
    };
    const dependencies = {
      'aws-sdk': '^2.1045.0',
    };
    for (const p in devDependencies) {
      if (!pkg.devDependencies[p]) {
        shouldBeFixed = true;
        pkg.devDependencies[p] = devDependencies[p];
      }
    }
    for (const p in dependencies) {
      if (!pkg.dependencies[p]) {
        shouldBeFixed = true;
        pkg.dependencies[p] = dependencies[p];
      }
    }
    if (shouldBeFixed && shouldWriteChanges) {
      writeFileSync(filePath, JSON.stringify(pkg, null, 2));
    }
    return shouldBeFixed;
  }

  private _getFunctionFileContents(f: Component): string {
    let returnType = 'void';
    let returnStatement: string = undefined;
    const eventImports: string[] = [];
    const evnVars: string[] = [];
    const eventTypes: string[] = [];
    for (let i = 0; i < f.inboundConnections.length; i++) {
      const conn = f.inboundConnections[i];
      switch (conn.source.type) {
        case 'ApiEndpoint':
          {
            if (conn.source.properties['apiType'] === 'Http') {
              eventImports.push('APIGatewayProxyEventV2');
              eventImports.push('APIGatewayProxyResultV2');
              eventTypes.push('APIGatewayProxyEventV2');
              returnType = 'APIGatewayProxyResultV2';
              evnVars.push('AllowedDomain');
              returnStatement = `  return {
    statusCode: 200,
    body: '',
    headers: {
      'content-type': 'application/json',
      'Access-Control-Allow-Headers': 'Content-Type',
      'Access-Control-Allow-Origin': AllowedDomain,
      'Access-Control-Allow-Methods': 'GET,PUT,PATCH,POST,DELETE',
    },
  };`;
            }
            if (conn.source.properties['apiType'] === 'Websocket') {
              eventImports.push('APIGatewayProxyWebsocketEventV2');
              eventImports.push('APIGatewayProxyStructuredResultV2');
              eventTypes.push('APIGatewayProxyWebsocketEventV2');
              returnType = 'APIGatewayProxyStructuredResultV2';
              returnStatement = `  return { statusCode: 200, body: 'OK' };`;
            }
          }
          break;

        case 'Bucket':
          eventImports.push('S3Event');
          eventTypes.push('S3Event');
          break;
        case 'EventBus':
          eventImports.push('EventBridgeEvent');
          eventTypes.push('EventBridgeEvent<string, unknown>');
          break;
        case 'Queue':
          eventImports.push('SQSEvent');
          eventTypes.push('SQSEvent');
          break;
        case 'Schedule':
          eventImports.push('ScheduledEvent');
          eventTypes.push('ScheduledEvent');
          break;
        case 'Table':
          eventImports.push('DynamoDBStreamEvent');
          eventTypes.push('DynamoDBStreamEvent');
          break;
        case 'Topic':
          eventImports.push('SNSEvent');
          eventTypes.push('SNSEvent');
          break;
      }
    }
    const uniqueEventImports = uniq(eventImports);
    const uniqueEventTypes = uniq(eventTypes);

    const handlerParams = uniqueEventTypes.length === 0 ? '' : `event: ${uniqueEventTypes.join(' | ')}`;

    const awsSdkImports: string[] = [];
    const awsSdkDeclarations: string[] = [];
    const remindingComments: string[] = [];
    for (let i = 0; i < f.outboundConnections.length; i++) {
      const conn = f.outboundConnections[i];
      switch (conn.target.type) {
        case 'Bucket':
          awsSdkImports.push(`import S3 from 'aws-sdk/clients/s3';`);
          awsSdkDeclarations.push(`const s3 = new S3();`);
          remindingComments.push(`// await s3.putObject({Bucket: ${conn.target.name}BucketName}).promise();`);
          evnVars.push(`${conn.target.name}BucketName`);
          break;
        case 'EventBus':
          awsSdkImports.push(`import EventBridge from 'aws-sdk/clients/eventbridge';`);
          awsSdkDeclarations.push(`const eventBridge = new EventBridge();`);
          remindingComments.push(
            `// await eventBridge.putEvents(Entries: [{EventBusName: ${conn.target.name}BusName}]).promise();`,
          );
          evnVars.push(`${conn.target.name}BusName`);
          break;
        case 'Queue':
          awsSdkImports.push(`import SQS from 'aws-sdk/clients/sqs';`);
          awsSdkDeclarations.push(`const sqs = new SQS();`);
          remindingComments.push(`// await sqs.sendMessage({QueueUrl: ${conn.target.name}QueueUrl}).promise();`);
          evnVars.push(`${conn.target.name}QueueUrl`);
          break;
        case 'Table':
          awsSdkImports.push(`import DocumentClient from 'aws-sdk/clients/dynamodb';`);
          awsSdkDeclarations.push(`const documentClient = new DocumentClient();`);
          remindingComments.push(`// await documentClient.get({TableName: ${conn.target.name}TableName}).promise();`);
          evnVars.push(`${conn.target.name}TableName`);
          break;
        case 'Topic':
          awsSdkImports.push(`import SNS from 'aws-sdk/clients/sns';`);
          awsSdkDeclarations.push(`const sns = new SNS();`);
          remindingComments.push(`// await sns.publish({TopicArn : ${conn.target.name}TopicArn}).promise();`);
          evnVars.push(`${conn.target.name}TopicArn`);
          break;
        case 'ApiEndpoint':
          if (conn.target.properties['apiType'] === 'Websocket') {
            awsSdkImports.push(`import APIGatewayManagementApi from 'aws-sdk/clients/apigatewaymanagementapi';`);
            evnVars.push(`${conn.target}ApiId`);
            evnVars.push(`${conn.target}Stage`);
            evnVars.push('AWS_REGION');
            returnStatement = `  const connectionIds: string[] = []; // TODO: get connectionId
  const postData = ''; // TODO: get postData
  const managementApi = new APIGatewayManagementApi({
    apiVersion: '2018-11-29',
    endpoint: \`https://\${${conn.target}ApiId}.execute-api.\${AWS_REGION}.amazonaws.com/\${${conn.target}Stage}\`,
  });

  const postCalls = connectionIds.map(async (connectionId) => {
    try {
      await managementApi.postToConnection({ ConnectionId: connectionId, Data: postData }).promise();
      console.log(\`Successfully sent message to \${connectionId}\`);
    } catch (e) {
      if (e.statusCode === 410) {
        console.log(\`Found stale connection \${connectionId}\`);
        // TODO: handle stale connection
      } else {
        console.log(\`Failed sending message to \${connectionId}\`);
        // TODO: handle other error
      }
    }

    await Promise.all(postCalls);
  });`;
          }
          break;
      }
    }
    const uniqueAwsSdkImports = uniq(awsSdkImports);
    const uniqueAwsSdkDeclarations = uniq(awsSdkDeclarations);
    const uniqueEnvVars = uniq(evnVars);
    const uniqueRemindingComments = uniq(remindingComments);

    let result = '';
    if (uniqueEventImports.length > 0) {
      result += `import { ${uniqueEventImports.join(', ')} } from 'aws-lambda';`;
      result += '\n';
    }
    if (uniqueAwsSdkImports.length > 0) {
      result += uniqueAwsSdkImports.join('\n');
      result += '\n\n';
    }
    if (uniqueEnvVars.length > 0) {
      result += `${uniqueEnvVars.map((v) => `const ${v} = process.env.${v};`).join('\n')}`;
      result += '\n\n';
    }
    if (uniqueAwsSdkDeclarations.length > 0) {
      result += `${uniqueAwsSdkDeclarations.join('\n')}`;
      result += '\n\n';
    }
    result += `export const Handler = async (${handlerParams}): Promise<${returnType}> => {`;
    result += '\n';
    if (uniqueRemindingComments.length > 0) {
      result += uniqueRemindingComments.map((c) => `  ${c}`).join('\n');
      result += '\n';
    }
    if (returnStatement) {
      result += returnStatement;
      result += '\n';
    }
    result += `};\n`;
    return result;
  }

  private _ensureFolderExists(path: string): void {
    if (existsSync(path)) return;
    mkdirSync(path, { recursive: true });
  }

  private _fixFunctionFile(f: Component, shouldWriteChanges: boolean) {
    const filePath = join(this.workspaceRoot, 'src', 'handlers', f.name, `${f.name}.ts`);
    const hasFile = existsSync(filePath);
    const shouldBeFixed = !hasFile;
    if (shouldBeFixed && shouldWriteChanges) {
      this._ensureFolderExists(join(this.workspaceRoot, 'src', 'handlers', f.name));
      writeFileSync(filePath, this._getFunctionFileContents(f));
    }
    return shouldBeFixed;
  }

  getFilesToBeUpdated(app: Application): string[] {
    const result: string[] = [];
    if (this._fixPackageFile(false)) {
      result.push('package.json');
    }
    for (const staticFile in StaticFiles) {
      if (this._fixStaticFile(staticFile, false)) {
        result.push(staticFile);
      }
    }
    const functions = app.components.filter((c) => c.type === 'Function');
    for (let i = 0; i < functions.length; i++) {
      const f = functions[i];
      if (this._fixFunctionFile(f, false)) {
        result.push(`src/handlers/${f.name}/${f.name}.ts`);
      }
    }
    return result;
  }
  update(app: Application): void {
    this._fixPackageFile(true);
    for (const staticFile in StaticFiles) {
      this._fixStaticFile(staticFile, true);
    }
    const functions = app.components.filter((c) => c.type === 'Function');
    for (let i = 0; i < functions.length; i++) {
      const f = functions[i];
      this._fixFunctionFile(f, true);
    }
  }
}
